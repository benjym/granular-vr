"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgranular_vr"] = self["webpackChunkgranular_vr"] || []).push([["vendors-node_modules_depasquale_three-immersive-controls_build_three-immersive-controls_js"],{

/***/ "./node_modules/@depasquale/three-immersive-controls/build/three-immersive-controls.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@depasquale/three-immersive-controls/build/three-immersive-controls.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CameraData\": () => (/* binding */ CameraData_default),\n/* harmony export */   \"ImmersiveButton\": () => (/* binding */ ImmersiveButton_default),\n/* harmony export */   \"Interaction\": () => (/* binding */ Interaction_default),\n/* harmony export */   \"createOverlay\": () => (/* binding */ createOverlay),\n/* harmony export */   \"default\": () => (/* binding */ build_default)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _depasquale_three_stats_mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @depasquale/three-stats-mesh */ \"./node_modules/@depasquale/three-stats-mesh/build/three-stats-mesh.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var three_examples_jsm_webxr_XRControllerModelFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/webxr/XRControllerModelFactory.js */ \"./node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js\");\n// build/ImmersiveControls.js\n\n\n\n// build/modules/controls/VRControls.js\n\n\n\n\n// build/modules/rounded-rectangle.js\nCanvasRenderingContext2D.prototype.roundedRectangle = function(x, y, width, height, rounded) {\n  const halfRadians = 2 * Math.PI / 2;\n  const quarterRadians = 2 * Math.PI / 4;\n  this.arc(rounded + x, rounded + y, rounded, -quarterRadians, halfRadians, true);\n  this.lineTo(x, y + height - rounded);\n  this.arc(rounded + x, height - rounded + y, rounded, halfRadians, quarterRadians, true);\n  this.lineTo(x + width - rounded, y + height);\n  this.arc(x + width - rounded, y + height - rounded, rounded, quarterRadians, 0, true);\n  this.lineTo(x + width, y + rounded);\n  this.arc(x + width - rounded, y + rounded, rounded, 0, -quarterRadians, true);\n  this.lineTo(x + rounded, y);\n};\n\n// build/modules/overlays.js\n\nvar getLines = (ctx, text, maxWidth) => {\n  const words = text.split(\" \");\n  const lines = [];\n  let currentLine = words[0];\n  for (let i = 1; i < words.length; i++) {\n    const word = words[i];\n    const width = ctx.measureText(`${currentLine} ${word}`).width;\n    if (width < maxWidth) {\n      currentLine += ` ${word}`;\n    } else {\n      lines.push(currentLine);\n      currentLine = word;\n    }\n  }\n  lines.push(currentLine);\n  return lines;\n};\nvar pixelsPerMeter = 1024;\nvar makeCanvasCtx = (canvas, nominalWidth, nominalHeight) => {\n  const scaleFactor = window.devicePixelRatio;\n  canvas.width = nominalWidth * scaleFactor;\n  canvas.height = nominalHeight * scaleFactor;\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    ctx.scale(scaleFactor, scaleFactor);\n    return ctx;\n  }\n  throw new Error(\"Could not find canvas\");\n};\nvar createTextProperties = ({ fontSize = 48, lineHeightRel = 1.15, margin = 20, fontColor = \"white\", font = \"BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, Helvetica, Arial, sans-serif\" } = {}) => {\n  const textProperties = {\n    fontSize,\n    font: `${fontSize}px ${font}`,\n    lineHeightRel,\n    lineHeight: fontSize * lineHeightRel,\n    margin,\n    fontColor\n  };\n  return textProperties;\n};\nvar getFinalNominalHeight = ({ text = \"\", overlayWidth = 0.75, textProperties = createTextProperties() }) => {\n  const overlayHeight = 1;\n  const nominalWidth = pixelsPerMeter * overlayWidth;\n  const nominalHeight = pixelsPerMeter * overlayHeight;\n  const canvas = document.createElement(\"canvas\");\n  const ctx = makeCanvasCtx(canvas, nominalWidth, nominalHeight);\n  if (ctx) {\n    ctx.font = textProperties.font;\n    const lines = getLines(ctx, text, nominalWidth - textProperties.margin * 2);\n    const finalNominalHeight = lines.length * textProperties.lineHeight + textProperties.margin * 2 - (textProperties.lineHeight - textProperties.fontSize) + textProperties.fontSize * 0.3;\n    return finalNominalHeight;\n  }\n  throw new Error(\"Could not make canvas context\");\n};\nvar createImage = ({ text = \"\", nominalWidth = pixelsPerMeter * 0.75, textProperties = createTextProperties(), finalNominalHeight = getFinalNominalHeight({ text, overlayWidth: nominalWidth, textProperties }), backgroundColor = \"rgba(0, 0, 0, 0.6)\", fitWidth = true }) => {\n  let canvas = document.createElement(\"canvas\");\n  let ctx = makeCanvasCtx(canvas, nominalWidth, finalNominalHeight);\n  if (ctx) {\n    ctx.fillStyle = backgroundColor;\n    ctx.roundedRectangle(0, 0, nominalWidth, finalNominalHeight, 20);\n    ctx.fill();\n    ctx.font = textProperties.font;\n    ctx.fillStyle = textProperties.fontColor;\n    const lines = getLines(ctx, text, nominalWidth - textProperties.margin * 2);\n    let fitNominalWidth;\n    if (fitWidth === true && lines.length === 1) {\n      fitNominalWidth = ctx.measureText(lines[0]).width + textProperties.margin * 2;\n      canvas = document.createElement(\"canvas\");\n      ctx = makeCanvasCtx(canvas, fitNominalWidth, finalNominalHeight);\n      if (ctx) {\n        ctx.fillStyle = backgroundColor;\n        ctx.roundedRectangle(0, 0, fitNominalWidth, finalNominalHeight, 20);\n        ctx.fill();\n        ctx.font = textProperties.font;\n        ctx.fillStyle = textProperties.fontColor;\n      } else {\n        console.error(\"No canvas context was provided\");\n      }\n    }\n    if (ctx) {\n      for (let i = 0; i < lines.length; i++) {\n        ctx.fillText(lines[i], textProperties.margin, textProperties.margin + textProperties.fontSize + i * textProperties.lineHeight);\n      }\n    } else {\n      console.error(\"No canvas context was provided\");\n    }\n    return { imageData: canvas.toDataURL(\"image/png\"), width: fitNominalWidth || nominalWidth };\n  }\n  throw new Error(\"Could not make canvas context\");\n};\nvar createOverlay = async ({ text = \"\", selectable = false, showActive = false, overlayWidth = 0.75, fitWidth = true, textProperties = createTextProperties() }) => {\n  const finalNominalHeight = getFinalNominalHeight({ text, overlayWidth, textProperties });\n  if (finalNominalHeight) {\n    const overlayHeight = finalNominalHeight / pixelsPerMeter;\n    const loader = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader();\n    const standardImg = createImage({\n      text,\n      nominalWidth: pixelsPerMeter * overlayWidth,\n      finalNominalHeight,\n      textProperties: createTextProperties(),\n      fitWidth,\n      backgroundColor: void 0\n    });\n    let standardTextureLoaded;\n    let intersectedTextureLoaded;\n    let activeStandardTextureLoaded;\n    let activeIntersectedTextureLoaded;\n    if (standardImg) {\n      standardTextureLoaded = new Promise((resolveStandardTextureLoaded) => {\n        loader.load(standardImg.imageData, (texture) => {\n          texture.minFilter = three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter;\n          resolveStandardTextureLoaded(texture);\n        });\n      });\n    } else {\n      throw new Error(\"standardImg was not created\");\n    }\n    if (selectable === true) {\n      const intersectedImg = createImage({\n        backgroundColor: \"rgba(76, 76, 76, 0.6)\",\n        text,\n        nominalWidth: pixelsPerMeter * overlayWidth,\n        finalNominalHeight,\n        textProperties: createTextProperties(),\n        fitWidth\n      });\n      if (intersectedImg) {\n        intersectedTextureLoaded = new Promise((resolveIntersectedTextureLoaded) => {\n          loader.load(intersectedImg.imageData, (texture) => {\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter;\n            resolveIntersectedTextureLoaded(texture);\n          });\n        });\n      } else {\n        throw new Error(\"intersectedImg was not created\");\n      }\n      if (showActive === true) {\n        const activeStandardImg = createImage({\n          backgroundColor: \"rgba(255, 0, 0, 0.6)\",\n          text,\n          nominalWidth: pixelsPerMeter * overlayWidth,\n          finalNominalHeight,\n          textProperties: createTextProperties(),\n          fitWidth\n        });\n        if (activeStandardImg) {\n          activeStandardTextureLoaded = new Promise((resolveActiveStandardTextureLoaded) => {\n            loader.load(activeStandardImg.imageData, (texture) => {\n              texture.minFilter = three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter;\n              resolveActiveStandardTextureLoaded(texture);\n            });\n          });\n        } else {\n          throw new Error(\"activeStandardImg was not created\");\n        }\n        const activeIntersectedImg = createImage({\n          backgroundColor: \"rgba(255, 76, 76, 0.6)\",\n          text,\n          nominalWidth: pixelsPerMeter * overlayWidth,\n          finalNominalHeight,\n          textProperties: createTextProperties(),\n          fitWidth\n        });\n        if (activeIntersectedImg) {\n          activeIntersectedTextureLoaded = new Promise((resolveActiveIntersectedTextureLoaded) => {\n            loader.load(activeIntersectedImg.imageData, (texture) => {\n              texture.minFilter = three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter;\n              resolveActiveIntersectedTextureLoaded(texture);\n            });\n          });\n        } else {\n          throw new Error(\"activeIntersectedImg was not created\");\n        }\n      }\n    }\n    if (standardImg) {\n      const overlayGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(standardImg.width / pixelsPerMeter, overlayHeight);\n      const overlayMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n        map: await standardTextureLoaded,\n        transparent: true\n      });\n      const overlayMesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(overlayGeometry, overlayMaterial);\n      if (selectable === true) {\n        overlayMesh.userData.textures = { standard: await standardTextureLoaded, intersected: await intersectedTextureLoaded };\n        if (showActive === true) {\n          overlayMesh.userData.textures.activeStandard = await activeStandardTextureLoaded;\n          overlayMesh.userData.textures.activeIntersected = await activeIntersectedTextureLoaded;\n          overlayMesh.userData.active = false;\n        }\n      }\n      return overlayMesh;\n    }\n    throw new Error(\"standardImg was not loaded\");\n  } else {\n    throw new Error(\"Could not calculate finalNominalHeight\");\n  }\n};\n\n// build/modules/ImmersiveButton.js\nvar ImmersiveButton = class {\n  constructor({ displayText, type, meshName, selectable = true, showActive = false, interaction }) {\n    this.displayText = displayText;\n    this.type = type;\n    this.meshName = meshName;\n    this.selectable = selectable;\n    this.showActive = showActive;\n    this.created = this.create();\n    this.interaction = interaction;\n  }\n  async create() {\n    const button = await createOverlay({ text: this.displayText, selectable: this.selectable, showActive: this.showActive });\n    button.name = this.meshName;\n    button.userData.type = this.type;\n    if (this.selectable === true) {\n      this.interaction.selectableObjects.push(button);\n    }\n    button.geometry.computeBoundingBox();\n    if (button.geometry.boundingBox) {\n      this.width = button.geometry.boundingBox.max.x - button.geometry.boundingBox.min.x;\n      this.height = button.geometry.boundingBox.max.y - button.geometry.boundingBox.min.y;\n    } else {\n      console.error(`No bounding box available for ${this.meshName}`);\n    }\n    this.mesh = button;\n  }\n};\nvar ImmersiveButton_default = ImmersiveButton;\n\n// build/modules/controls/VRControls.js\nvar xAxis = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 0, 0);\nvar yAxis = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0);\nvar VRControls = class {\n  constructor(controls, { showControllerModel = false, showEnterVRButton = true, showExitVRButton = true } = {}) {\n    this.controls = controls;\n    this.currentVrSession = null;\n    this.controls.renderer.xr.enabled = true;\n    this.showControllerModel = showControllerModel;\n    this.showEnterVRButton = showEnterVRButton;\n    this.showExitVRButton = showExitVRButton;\n    this.firstEnteredVr = false;\n    this.cameraHeightInitialized = false;\n    this.inVr = this.controls.renderer.xr.isPresenting === true || false;\n    this.controllers = { left: void 0, right: void 0 };\n    this.controllerGrips = { left: void 0, right: void 0 };\n    this.lastFrameLeftThumbstickWas0 = true;\n    this.lastFrameRightThumbstickWas0 = true;\n    this.leftThumbstickInertia = { val: 1 };\n    this.rightThumbstickInertia = { val: 1 };\n    this.leftThumbstickMomentum = { val: 0 };\n    this.rightThumbstickXMomentum = { val: 0 };\n    this.rightThumbstickYMomentum = { val: 0 };\n    this.thumbstickMax = 1;\n    this.buttons = {\n      right: {\n        a: { previousFrame: void 0, thisFrame: void 0, buttonUp: void 0, buttonDown: void 0 },\n        b: { previousFrame: void 0, thisFrame: void 0, buttonUp: void 0, buttonDown: void 0 },\n        trigger: { previousFrame: void 0, thisFrame: void 0, buttonUp: void 0, buttonDown: void 0 }\n      },\n      left: {\n        a: { previousFrame: void 0, thisFrame: void 0, buttonUp: void 0, buttonDown: void 0 },\n        b: { previousFrame: void 0, thisFrame: void 0, buttonUp: void 0, buttonDown: void 0 },\n        trigger: { previousFrame: void 0, thisFrame: void 0, buttonUp: void 0, buttonDown: void 0 }\n      }\n    };\n    this.controllerModelFactory = new three_examples_jsm_webxr_XRControllerModelFactory_js__WEBPACK_IMPORTED_MODULE_2__.XRControllerModelFactory();\n    this.firstControllerReady = this.getController(0);\n    this.secondControllerReady = this.getController(1);\n    if (this.showEnterVRButton === true) {\n      let buttonsContainer = document.getElementById(\"buttonsContainer\");\n      if (!buttonsContainer) {\n        buttonsContainer = document.createElement(\"div\");\n        buttonsContainer.id = \"buttonsContainer\";\n        document.body.append(buttonsContainer);\n      }\n      const enterVRButton = document.createElement(\"button\");\n      enterVRButton.id = \"enterVRButton\";\n      enterVRButton.classList.add(\"button\");\n      enterVRButton.append(\"Enter VR\");\n      enterVRButton.addEventListener(\"click\", () => {\n        this.enterVR();\n      });\n      buttonsContainer?.prepend(enterVRButton);\n    }\n    this.userButtons = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n    this.hideUserButtons();\n    this.repositionUserButtons();\n    this.controls.player.add(this.userButtons);\n    if (this.showExitVRButton === true) {\n      const exitVRButton = new ImmersiveButton_default({\n        displayText: \"Exit VR\",\n        type: \"exitVRButton\",\n        meshName: \"Exit VR button\",\n        selectable: true,\n        showActive: false,\n        interaction: this.controls.interaction\n      });\n      exitVRButton.created.then(() => {\n        this.userButtons.add(exitVRButton.mesh);\n      });\n      if (!(\"exitVRButton\" in this.controls.interaction.selectEndHandlers)) {\n        this.controls.interaction.selectEndHandlers.exitVRButton = this.exitVR.bind(this);\n      } else {\n        console.error(\"Attempting to set selection handler for object of type `exitVRButton`, but a handler for this object type has already been set.\");\n      }\n      if (!(\"exitVRButton\" in this.controls.interaction.intersectionHandlers)) {\n        this.controls.interaction.intersectionHandlers.exitVRButton = this.resetUserButtonRepositionTimer.bind(this);\n      } else {\n        console.error(\"Attempting to set selection handler for object of type `exitVRButton`, but a handler for this object type has already been set.\");\n      }\n    }\n  }\n  enterVR() {\n    const sessionInit = { optionalFeatures: [\"local-floor\", \"bounded-floor\", \"hand-tracking\", \"layers\"] };\n    navigator.xr?.requestSession(\"immersive-vr\", sessionInit).then(async (session) => {\n      console.debug(\"Entered VR\");\n      await this.controls.renderer.xr.setSession(session);\n      session.addEventListener(\"end\", () => {\n      });\n      this.currentVrSession = session;\n      console.debug(`cameraHeight: ${this.cameraHeight}`);\n      this.inVr = true;\n      this.showUserButtons();\n      this.repositionUserButtons();\n    });\n  }\n  exitVR() {\n    this.currentVrSession?.end();\n    console.debug(\"Exited VR mode\");\n    console.debug(`cameraHeight: ${this.cameraHeight}`);\n    this.hideUserButtons();\n    this.inVr = false;\n  }\n  resetUserButtonRepositionTimer() {\n    clearInterval(this.userButtonRepositionTimer);\n    this.userButtonRepositionTimer = setInterval(() => {\n      this.repositionUserButtons();\n    }, 15e3);\n  }\n  repositionUserButtons() {\n    this.resetUserButtonRepositionTimer();\n    const gazeVector = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, -1).applyQuaternion(this.controls.camera.quaternion);\n    gazeVector.setY(0);\n    gazeVector.normalize();\n    const gazeVectorRotated = gazeVector.applyAxisAngle(yAxis, Math.PI / 5);\n    this.userButtons.position.copy(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3().addVectors(this.controls.camera.position, gazeVectorRotated));\n    this.userButtons.position.y -= 0.75;\n    this.userButtons.lookAt(this.controls.cameraData.worldPosition);\n  }\n  getScale(thumbstickVal) {\n    if (Math.abs(thumbstickVal) > this.thumbstickMax) {\n      this.thumbstickMax = Math.abs(thumbstickVal);\n    }\n    return 1 / this.thumbstickMax;\n  }\n  showUserButtons() {\n    this.userButtons.visible = true;\n    this.userButtons.children.forEach((child) => {\n      child.visible = true;\n    });\n  }\n  hideUserButtons() {\n    this.userButtons.visible = false;\n    this.userButtons.children.forEach((child) => {\n      child.visible = false;\n    });\n  }\n  update() {\n    _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.update();\n    if (this.inVr === true) {\n      if (this.controllers.left) {\n        this.handleControllerIntersections(this.controllers.left);\n      }\n      if (this.controllers.right) {\n        this.handleControllerIntersections(this.controllers.right);\n      }\n    }\n    const sides = [\"left\", \"right\"];\n    const buttons = { trigger: 0, a: 4, b: 5 };\n    sides.forEach((side) => {\n      Object.keys(buttons).forEach((buttonName) => {\n        const buttonIndex = buttons[buttonName];\n        if (this.controllers[side]?.gamepad.buttons[buttonIndex]) {\n          this.buttons[side][buttonName].previousFrame = this.buttons[side][buttonName].thisFrame;\n          this.buttons[side][buttonName].thisFrame = this.controllers[side]?.gamepad.buttons[buttonIndex].pressed;\n          if (this.buttons[side][buttonName].previousFrame === true && this.buttons[side][buttonName].thisFrame === false) {\n            this.buttons[side][buttonName].buttonUp = true;\n          } else {\n            this.buttons[side][buttonName].buttonUp = false;\n          }\n          if (this.buttons[side][buttonName].previousFrame === false && this.buttons[side][buttonName].thisFrame === true) {\n            this.buttons[side][buttonName].buttonDown = true;\n          } else {\n            this.buttons[side][buttonName].buttonDown = false;\n          }\n        } else {\n          this.buttons[side][buttonName].previousFrame = void 0;\n          this.buttons[side][buttonName].thisFrame = void 0;\n        }\n      });\n    });\n    if (this.inVr === true && (this.buttons.left.b.buttonUp === true || this.buttons.right.b.buttonUp === true)) {\n      if (this.userButtons.visible === true) {\n        this.hideUserButtons();\n      } else {\n        this.showUserButtons();\n        this.repositionUserButtons();\n      }\n    }\n    this.cameraHeight = this.controls.cameraData.worldPosition.y - this.controls.player.position.y;\n    if (this.controls.renderer.xr.isPresenting === true) {\n      if (this.firstEnteredVr === true && this.cameraHeightInitialized === false) {\n        if (this.cameraHeight !== 0) {\n          this.cameraHeightInitialized = true;\n          this.initialCameraHeight = this.cameraHeight;\n          console.debug(\"Camera height initialized after entering VR\");\n          console.debug(`cameraHeight: ${this.cameraHeight}`);\n          console.debug(`Player height before adjusting: ${this.controls.player.position.y}`);\n          this.controls.player.position.y -= this.cameraHeight;\n          console.debug(`Player height after adjusting: ${this.controls.player.position.y}`);\n          this.controls.cameraData.worldPosition.y -= this.cameraHeight;\n          this.showUserButtons();\n          this.repositionUserButtons();\n        }\n      }\n      if (this.firstEnteredVr === false) {\n        this.firstEnteredVr = true;\n      }\n    }\n    if (this.controllerGrips.left && this.controls.renderer.xr.isPresenting === true) {\n      const leftControllerWorldPosition = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n      const leftControllerWorldRotation = new three__WEBPACK_IMPORTED_MODULE_3__.Quaternion();\n      const leftControllerWorldScale = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n      this.controllerGrips.left.matrixWorld.decompose(leftControllerWorldPosition, leftControllerWorldRotation, leftControllerWorldScale);\n      this.leftControllerWorldData = { position: leftControllerWorldPosition, rotation: leftControllerWorldRotation, scale: leftControllerWorldScale };\n    } else {\n      this.leftControllerWorldData = void 0;\n    }\n    if (this.controllerGrips.right && this.controls.renderer.xr.isPresenting === true) {\n      const rightControllerWorldPosition = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n      const rightControllerWorldRotation = new three__WEBPACK_IMPORTED_MODULE_3__.Quaternion();\n      const rightControllerWorldScale = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n      this.controllerGrips.right.matrixWorld.decompose(rightControllerWorldPosition, rightControllerWorldRotation, rightControllerWorldScale);\n      this.rightControllerWorldData = { position: rightControllerWorldPosition, rotation: rightControllerWorldRotation, scale: rightControllerWorldScale };\n    } else {\n      this.rightControllerWorldData = void 0;\n    }\n    const moveSpeedPerMillisecond = this.controls.moveSpeed.vr / 1e3;\n    const rotateSpeedPerMillisecond = this.controls.rotateSpeed / 1e3;\n    if (this.controllers.left && this.controllers.left.gamepad) {\n      let thumbstickX = this.controllers.left.gamepad.axes[2];\n      let thumbstickY = this.controllers.left.gamepad.axes[3];\n      thumbstickX *= this.getScale(thumbstickX);\n      thumbstickY *= this.getScale(thumbstickY);\n      thumbstickX **= 2;\n      thumbstickY **= 2;\n      if (this.controllers.left.gamepad.axes[2] < 0) {\n        thumbstickX *= -1;\n      }\n      if (this.controllers.left.gamepad.axes[3] < 0) {\n        thumbstickY *= -1;\n      }\n      if (this.lastFrameLeftThumbstickWas0 === true && (thumbstickY !== 0 || thumbstickX !== 0)) {\n        this.leftThumbstickTween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(this.leftThumbstickInertia).to({ val: 0 }, 1e3).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).start();\n      }\n      const inertiaCoefficient = 1 - this.leftThumbstickInertia.val;\n      const movementValZ = moveSpeedPerMillisecond * this.controls.millisecondsSinceLastFrame * thumbstickY * inertiaCoefficient;\n      const movementValX = moveSpeedPerMillisecond * this.controls.millisecondsSinceLastFrame * thumbstickX * inertiaCoefficient;\n      this.leftThumbstickMomentum.val = thumbstickY;\n      const move = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(movementValX, 0, movementValZ).applyQuaternion(this.controls.cameraData.worldRotation);\n      if (typeof this.controls.floor === \"number\" && move.y !== 0) {\n        const minPlayerY = this.controls.floor + this.controls.eyeLevel - this.initialCameraHeight;\n        const moveYResult = this.controls.player.position.y + move.y;\n        if (this.controls.gravity === true || moveYResult < minPlayerY) {\n          const diff = moveYResult - minPlayerY;\n          move.y -= diff;\n        }\n      }\n      this.controls.player.position.add(move);\n      if (thumbstickY !== 0) {\n        this.lastFrameLeftThumbstickWas0 = false;\n      } else {\n        this.lastFrameLeftThumbstickWas0 = true;\n        if (this.leftThumbstickTween) {\n          this.leftThumbstickTween.stop();\n        }\n        this.leftThumbstickInertia.val = 1;\n      }\n    }\n    if (this.controllers.right?.gamepad) {\n      let thumbstickX = this.controllers.right.gamepad.axes[2];\n      let thumbstickY = this.controllers.right.gamepad.axes[3];\n      thumbstickX *= this.getScale(thumbstickX);\n      thumbstickY *= this.getScale(thumbstickY);\n      if (this.lastFrameRightThumbstickWas0 && (thumbstickX !== 0 || thumbstickY !== 0)) {\n        this.rightThumbstickTween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(this.rightThumbstickInertia).to({ val: 0 }, 750).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).start();\n      }\n      const inertiaCoefficient = 1 - this.rightThumbstickInertia.val;\n      if (thumbstickX !== 0 || thumbstickY !== 0 && this.controls.tumble === true) {\n        const yRotationAmount = rotateSpeedPerMillisecond * this.controls.millisecondsSinceLastFrame * thumbstickX * inertiaCoefficient;\n        const diff = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3().subVectors(this.controls.cameraData.worldPosition, this.controls.player.position);\n        this.controls.player.position.add(diff);\n        this.controls.player.rotateOnAxis(yAxis, -yRotationAmount);\n        let xRotationAmount;\n        if (thumbstickY !== 0 && this.controls.tumble === true) {\n          xRotationAmount = rotateSpeedPerMillisecond * this.controls.millisecondsSinceLastFrame * thumbstickY * inertiaCoefficient;\n          this.controls.player.rotateOnAxis(xAxis, xRotationAmount);\n        }\n        const rotatedDiff = diff.applyEuler(new three__WEBPACK_IMPORTED_MODULE_3__.Euler(xRotationAmount || 0, -yRotationAmount, 0));\n        this.controls.player.position.sub(rotatedDiff);\n      }\n      if (thumbstickX !== 0 || thumbstickY !== 0) {\n        this.lastFrameRightThumbstickWas0 = false;\n      } else {\n        this.lastFrameRightThumbstickWas0 = true;\n        if (this.rightThumbstickTween) {\n          this.rightThumbstickTween.stop();\n        }\n        this.rightThumbstickInertia.val = 1;\n      }\n    }\n  }\n  getControllerIntersections(controller, objects) {\n    this.controls.tempMatrix.identity().extractRotation(controller.matrixWorld);\n    this.controls.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);\n    this.controls.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.controls.tempMatrix);\n    return this.controls.raycaster.intersectObjects(objects, true).filter((intersection) => intersection.object.visible === true);\n  }\n  handleControllerIntersections(controller) {\n    const controllerLine = controller.getObjectByName(\"line\");\n    if (controllerLine) {\n      const intersections = this.getControllerIntersections(controller, this.controls.interaction.selectableObjects);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const object = intersection.object;\n        if (object instanceof three__WEBPACK_IMPORTED_MODULE_3__.Mesh) {\n          this.controls.interaction.handleIntersection(object);\n        }\n        controllerLine.scale.z = intersection.distance;\n        let buttonSide;\n        if (controller.side === \"right\") {\n          buttonSide = this.buttons.right;\n        } else if (controller.side === \"left\") {\n          buttonSide = this.buttons.left;\n        }\n        if ((buttonSide?.a.buttonDown === true || buttonSide?.trigger.buttonDown === true) && object.visible === true) {\n          this.controls.interaction.handleSelectStart(object, controller);\n        }\n        if ((buttonSide?.a.buttonUp === true || buttonSide?.trigger.buttonUp === true) && object.visible === true) {\n          this.controls.interaction.handleSelectEnd(object, controller);\n        }\n      } else {\n        controllerLine.scale.z = 5;\n      }\n    } else {\n      console.error(\"Object `line` could not be found on controller\");\n    }\n  }\n  getController(i) {\n    const lineGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints([new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, -1)]);\n    const lineMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n      color: 16777215,\n      transparent: true,\n      opacity: 0.1\n    });\n    const line = new three__WEBPACK_IMPORTED_MODULE_3__.Line(lineGeometry, lineMaterial);\n    line.name = \"line\";\n    line.scale.z = 5;\n    return new Promise((resolve) => {\n      const controller = this.controls.renderer.xr.getController(i);\n      controller.addEventListener(\"connected\", (e) => {\n        const controllerGrip = this.controls.renderer.xr.getControllerGrip(i);\n        if (this.showControllerModel === true) {\n          controllerGrip.add(this.controllerModelFactory.createControllerModel(controllerGrip));\n        }\n        const session = this.controls.renderer.xr.getSession();\n        if (session) {\n          if (session.inputSources[i]?.handedness === \"right\") {\n            controller.side = \"right\";\n            this.controllers.right = controller;\n            this.controllerGrips.right = controllerGrip;\n            this.controllers.right.add(line.clone());\n          } else if (session.inputSources[i]?.handedness === \"left\") {\n            controller.side = \"left\";\n            this.controllers.left = controller;\n            this.controllerGrips.left = controllerGrip;\n            this.controllers.left.add(line.clone());\n          } else {\n            console.error(\"Error assigning controller to right or left hand\");\n          }\n          this.controls.player.add(controllerGrip, controller);\n          controller.gamepad = e.data.gamepad;\n        } else {\n          console.error(\"No XR session found\");\n        }\n        resolve();\n      });\n      controller.addEventListener(\"disconnected\", () => {\n        console.debug(`Controller ${i} disconnected`);\n      });\n    });\n  }\n  controllersReady(cb) {\n    this.firstControllerReady.then(cb);\n    this.secondControllerReady.then(cb);\n  }\n};\nvar VRControls_default = VRControls;\n\n// build/modules/controls/KeyboardControls.js\n\n\nvar inertiaTweenDuration = 350;\nvar xAxis2 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 0, 0);\nvar yAxis2 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0);\nvar KeyboardControls = class {\n  constructor(controls) {\n    this.controls = controls;\n    this.keysPressed = [];\n    this.keysToIgnore = [];\n    this.activeKeys = [];\n    this.lastFrameMovementWas0 = true;\n    this.lastFrameRotationWas0 = true;\n    this.movementInertia = { val: 1 };\n    this.rotationInertia = { val: 1 };\n    this.veticalRotationThreshold = 0.95;\n    this.xRotation = 0;\n    this.yRotation = 0;\n    this.hotKeys = [\"KeyW\", \"KeyS\", \"KeyA\", \"KeyD\", \"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\"];\n    this.opposites = {\n      KeyW: \"KeyS\",\n      KeyS: \"KeyW\",\n      KeyA: \"KeyD\",\n      KeyD: \"KeyA\",\n      ArrowLeft: \"ArrowRight\",\n      ArrowRight: \"ArrowLeft\",\n      ArrowUp: \"ArrowDown\",\n      ArrowDown: \"ArrowUp\"\n    };\n    window.addEventListener(\"keydown\", (e) => {\n      const key = (e.code ? e.code : e.which).toString();\n      if (this.hotKeys.includes(key) && !this.keysPressed.includes(key)) {\n        this.keysPressed.push(key);\n        if (this.keysPressed.includes(this.opposites[key]) && !this.keysToIgnore.includes(this.opposites[key])) {\n          this.keysToIgnore.push(this.opposites[key]);\n        }\n      }\n      this.selectActiveKeys();\n    });\n    window.addEventListener(\"keyup\", (e) => {\n      const key = (e.code ? e.code : e.which).toString();\n      if (this.hotKeys.includes(key)) {\n        if (this.keysPressed.includes(key)) {\n          KeyboardControls.removeItem(this.keysPressed, key);\n          if (this.keysToIgnore.includes(this.opposites[key])) {\n            KeyboardControls.removeItem(this.keysToIgnore, this.opposites[key]);\n          }\n        }\n        if (this.keysToIgnore.includes(key)) {\n          KeyboardControls.removeItem(this.keysToIgnore, key);\n        }\n      }\n      this.selectActiveKeys();\n    });\n  }\n  selectActiveKeys() {\n    this.activeKeys = [];\n    this.keysPressed.forEach((key) => {\n      if (!this.keysToIgnore.includes(key)) {\n        this.activeKeys.push(key);\n      }\n    });\n  }\n  static removeItem(array, item) {\n    for (let i = 0; i < array.length; i++) {\n      if (array[i] === item) {\n        array.splice(i, 1);\n        break;\n      }\n    }\n  }\n  rotate() {\n    let vector = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, -1);\n    vector.applyAxisAngle(xAxis2, this.xRotation);\n    vector.applyAxisAngle(yAxis2, this.yRotation);\n    vector = vector.negate();\n    const lookAtPoint = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3().addVectors(this.controls.player.position, vector);\n    this.controls.player.lookAt(lookAtPoint);\n  }\n  rotateLeft(rotationAmount) {\n    this.yRotation += rotationAmount;\n  }\n  rotateRight(rotationAmount) {\n    this.yRotation -= rotationAmount;\n  }\n  rotateUp(rotationAmount) {\n    if (this.xRotation + rotationAmount < Math.PI / 2 * this.veticalRotationThreshold) {\n      this.xRotation += rotationAmount;\n    }\n  }\n  rotateDown(rotationAmount) {\n    if (this.xRotation - rotationAmount > -Math.PI / 2 * this.veticalRotationThreshold) {\n      this.xRotation -= rotationAmount;\n    }\n  }\n  update() {\n    _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.update();\n    const moveSpeedPerMillisecond = this.controls.moveSpeed.keyboard / 1e3;\n    const rotateSpeedPerMillisecond = this.controls.rotateSpeed / 1e3;\n    let movementKeyActive = false;\n    if (this.activeKeys.includes(\"KeyW\") || this.activeKeys.includes(\"KeyS\") || this.activeKeys.includes(\"KeyA\") || this.activeKeys.includes(\"KeyD\")) {\n      movementKeyActive = true;\n    }\n    if (this.lastFrameMovementWas0 === true && movementKeyActive === true) {\n      this.movementTween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(this.movementInertia).to({ val: 0 }, inertiaTweenDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).start();\n    }\n    const movementInertiaCoefficient = 1 - this.movementInertia.val;\n    const movementAmount = moveSpeedPerMillisecond * this.controls.millisecondsSinceLastFrame * movementInertiaCoefficient;\n    const move = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n    let rotationKeyActive = false;\n    if (this.activeKeys.includes(\"ArrowUp\") || this.activeKeys.includes(\"ArrowDown\") || this.activeKeys.includes(\"ArrowRight\") || this.activeKeys.includes(\"ArrowLeft\")) {\n      rotationKeyActive = true;\n    }\n    if (this.lastFrameRotationWas0 === true && rotationKeyActive === true) {\n      this.rotationTween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(this.rotationInertia).to({ val: 0 }, inertiaTweenDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).start();\n    }\n    const rotationInertiaCoefficient = 1 - this.rotationInertia.val;\n    const rotationAmount = rotateSpeedPerMillisecond * this.controls.millisecondsSinceLastFrame * rotationInertiaCoefficient;\n    let movementFlag = true;\n    if (this.activeKeys.includes(\"KeyW\")) {\n      move.add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, -movementAmount).applyQuaternion(this.controls.cameraData.worldRotation));\n      movementFlag = false;\n    } else if (this.activeKeys.includes(\"KeyS\")) {\n      move.add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, movementAmount).applyQuaternion(this.controls.cameraData.worldRotation));\n      movementFlag = false;\n    }\n    if (this.activeKeys.includes(\"KeyA\")) {\n      move.add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(-movementAmount, 0, 0).applyQuaternion(this.controls.cameraData.worldRotation));\n      movementFlag = false;\n    } else if (this.activeKeys.includes(\"KeyD\")) {\n      move.add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(movementAmount, 0, 0).applyQuaternion(this.controls.cameraData.worldRotation));\n      movementFlag = false;\n    }\n    if (movementFlag === true) {\n      this.lastFrameMovementWas0 = true;\n      this.movementInertia.val = 1;\n    } else {\n      this.lastFrameMovementWas0 = false;\n    }\n    if (typeof this.controls.floor === \"number\" && move.y !== 0) {\n      const minPlayerY = this.controls.floor + this.controls.eyeLevel;\n      const moveYResult = this.controls.player.position.y + move.y;\n      if (this.controls.gravity === true || moveYResult < minPlayerY) {\n        const diff = moveYResult - minPlayerY;\n        move.y -= diff;\n      }\n    }\n    this.controls.player.position.add(move);\n    let needToRotate = false;\n    if (this.activeKeys.includes(\"ArrowLeft\")) {\n      this.rotateLeft(rotationAmount);\n      needToRotate = true;\n    } else if (this.activeKeys.includes(\"ArrowRight\")) {\n      this.rotateRight(rotationAmount);\n      needToRotate = true;\n    }\n    if (this.activeKeys.includes(\"ArrowUp\")) {\n      this.rotateUp(rotationAmount);\n      needToRotate = true;\n    } else if (this.activeKeys.includes(\"ArrowDown\")) {\n      this.rotateDown(rotationAmount);\n      needToRotate = true;\n    }\n    if (needToRotate === true) {\n      this.rotate();\n      this.lastFrameRotationWas0 = false;\n    } else {\n      this.lastFrameRotationWas0 = true;\n      this.rotationInertia.val = 1;\n    }\n  }\n};\nvar KeyboardControls_default = KeyboardControls;\n\n// build/modules/controls/MouseControls.js\n\nvar MouseControls = class {\n  constructor(controls) {\n    this.controls = controls;\n    this.mousePosition = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();\n    this.controls.renderer.domElement.addEventListener(\"mousemove\", (event) => {\n      this.mousePosition.x = event.clientX / window.innerWidth * 2 - 1;\n      this.mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    });\n    this.controls.renderer.domElement.addEventListener(\"mousedown\", () => {\n      if (this.controls.interaction.intersectedObjects.length > 0 && this.controls.interaction.intersectedObjects[0].visible === true) {\n        this.controls.interaction.handleSelectStart(this.controls.interaction.intersectedObjects[0]);\n      }\n    });\n    this.controls.renderer.domElement.addEventListener(\"click\", () => {\n      if (this.controls.interaction.intersectedObjects.length > 0 && this.controls.interaction.intersectedObjects[0].visible === true) {\n        this.controls.interaction.handleSelectEnd(this.controls.interaction.intersectedObjects[0]);\n      }\n    });\n  }\n  update() {\n    if (!this.controls.vrControls?.inVr) {\n      this.controls.raycaster.setFromCamera(this.mousePosition, this.controls.camera);\n      this.intersections = this.controls.raycaster.intersectObjects(this.controls.interaction.selectableObjects);\n      if (this.intersections.length > 0 && this.intersections[0].object.visible === true && this.intersections[0].object instanceof three__WEBPACK_IMPORTED_MODULE_3__.Mesh) {\n        this.controls.interaction.handleIntersection(this.intersections[0].object);\n      }\n    }\n  }\n};\nvar MouseControls_default = MouseControls;\n\n// build/modules/Interaction.js\n\nvar Interaction = class {\n  constructor() {\n    this.intersectedObjects = [];\n    this.selectableObjects = [];\n    this.intersectedObjectEmissiveVal = 0.3;\n    this.intersectionHandlers = {};\n    this.selectStartHandlers = {};\n    this.selectEndHandlers = {};\n  }\n  handleSelectStart(object, controller) {\n    console.debug(`Select start occurred on ${object.name || object.userData.type}`);\n    if (object.userData.type in this.selectStartHandlers) {\n      this.selectStartHandlers[object.userData.type](object, controller);\n    } else {\n      console.error(`Select start occurred on object of type ${object.userData.type}, but no handler was set for this type.`);\n    }\n  }\n  handleSelectEnd(object, controller) {\n    console.debug(`Select end occurred on ${object.name || object.userData.type}`);\n    if (object.userData.type in this.selectEndHandlers) {\n      this.selectEndHandlers[object.userData.type](object, controller);\n    } else {\n      console.error(`Select end occurred on object of type ${object.userData.type}, but no handler was set for this type.`);\n    }\n  }\n  cleanIntersected() {\n    while (this.intersectedObjects.length) {\n      const object = this.intersectedObjects.pop();\n      if (object instanceof three__WEBPACK_IMPORTED_MODULE_3__.Mesh) {\n        object.material.emissive?.setScalar(0);\n        Interaction.handleButtonMaterialMaps(object, false);\n      }\n    }\n  }\n  static handleButtonMaterialMaps(object, intersected = false) {\n    if (object.userData.textures && object.material instanceof three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial) {\n      if (object.userData.active === true) {\n        object.material.map = intersected ? object.userData.textures.activeIntersected : object.userData.textures.activeStandard;\n      } else {\n        object.material.map = intersected ? object.userData.textures.intersected : object.userData.textures.standard;\n      }\n    }\n  }\n  handleIntersection(object) {\n    this.intersectedObjects.push(object);\n    Interaction.handleButtonMaterialMaps(object, true);\n    if (object.material instanceof three__WEBPACK_IMPORTED_MODULE_3__.MeshStandardMaterial) {\n      object.material.emissive?.setScalar(this.intersectedObjectEmissiveVal);\n    }\n    if (object.userData.type in this.intersectionHandlers) {\n      this.intersectionHandlers[object.userData.type](object);\n    }\n  }\n};\nvar Interaction_default = Interaction;\n\n// build/modules/CameraData.js\n\nvar CameraData = class {\n  constructor(camera) {\n    this.camera = camera;\n    this.worldPosition = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n    this.worldRotation = new three__WEBPACK_IMPORTED_MODULE_3__.Quaternion();\n    this.worldScale = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n    this.update();\n  }\n  update() {\n    this.camera.matrixWorld.decompose(this.worldPosition, this.worldRotation, this.worldScale);\n  }\n};\nvar CameraData_default = CameraData;\n\n// build/ImmersiveControls.js\nvar eyeLevel = 1.6;\nvar ThreeImmersiveControls = class {\n  constructor(camera, renderer, scene, {\n    initialPosition = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, eyeLevel, 4),\n    lookAt = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(initialPosition.x, initialPosition.y, initialPosition.z - 1e4),\n    floor = 0,\n    gravity = true,\n    moveSpeed = { vr: 2.5, keyboard: 5 },\n    rotateSpeed = 1,\n    tumble = false,\n    showControllerModel = true,\n    showEnterVRButton = true,\n    showExitVRButton = true,\n    vrControls = true,\n    keyboardControls = true,\n    mouseControls = true,\n    showFps = false\n  } = {}) {\n    this.camera = camera;\n    this.renderer = renderer;\n    this.scene = scene;\n    this.player = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n    this.player.position.copy(initialPosition);\n    this.scene.add(this.player);\n    this.player.add(this.camera);\n    this.camera.position.set(0, 0, 0);\n    this.floor = floor;\n    this.gravity = gravity;\n    this.moveSpeed = moveSpeed;\n    this.rotateSpeed = rotateSpeed;\n    this.tumble = tumble;\n    this.eyeLevel = eyeLevel;\n    this.interaction = new Interaction_default();\n    this.cameraData = new CameraData_default(this.camera);\n    this.tempMatrix = new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\n    this.raycaster = new three__WEBPACK_IMPORTED_MODULE_3__.Raycaster();\n    this.vrSupported = new Promise((resolve) => {\n      if (\"xr\" in navigator) {\n        navigator.xr?.isSessionSupported(\"immersive-vr\").then((vrSupported) => {\n          if (vrSupported === true) {\n            console.debug(\"VR is supported.\");\n            resolve(true);\n          } else {\n            console.debug(\"VR is not supported.\");\n            resolve(false);\n          }\n        });\n      } else {\n        console.debug(\"VR is not supported.\");\n        resolve(false);\n      }\n    });\n    if (vrControls === true) {\n      this.vrSupported.then((vrSupported) => {\n        if (vrSupported === true) {\n          this.vrControls = new VRControls_default(this, { showControllerModel, showEnterVRButton, showExitVRButton });\n        }\n      });\n    }\n    if (keyboardControls === true) {\n      this.keyboardControls = new KeyboardControls_default(this);\n    }\n    if (mouseControls === true) {\n      this.mouseControls = new MouseControls_default(this);\n    }\n    this.millisecondsSinceLastFrame = 0;\n    this.lastUpdate = performance.now();\n    this.showFps = showFps;\n    if (this.showFps === true) {\n      this.statsMesh = new _depasquale_three_stats_mesh__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      document.body.appendChild(this.statsMesh.stats.dom);\n      this.vrSupported.then((vrSupported) => {\n        if (vrSupported === true) {\n          if (this.vrControls && this.statsMesh) {\n            this.statsMesh.object.position.y = -0.25;\n            this.vrControls.userButtons.add(this.statsMesh.object);\n          } else {\n            console.error(\"vrControls does not exist\");\n          }\n        }\n      });\n    }\n    window.controls = this;\n  }\n  update() {\n    const now = performance.now();\n    this.millisecondsSinceLastFrame = now - this.lastUpdate;\n    this.lastUpdate = now;\n    this.cameraData.update();\n    this.interaction.cleanIntersected();\n    if (this.showFps === true) {\n      this.statsMesh?.stats.update();\n    }\n    this.vrControls?.update();\n    this.keyboardControls?.update();\n    this.mouseControls?.update();\n  }\n};\nvar ImmersiveControls_default = ThreeImmersiveControls;\n\n// build/index.js\nvar build_default = ImmersiveControls_default;\n\n/*!\nThree.js Immersive Controls\nCopyright 2022, Anthony DePasquale (anthony@depasquale.org)\n*/\n/*!\nroundedRectangle by Aaron Newell\nhttps://newfivefour.com/javascript-canvas-rounded-rectangle.html\n*/\n\n\n//# sourceURL=webpack://granular-vr/./node_modules/@depasquale/three-immersive-controls/build/three-immersive-controls.js?");

/***/ })

}]);